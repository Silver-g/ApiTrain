package userservice

import (
	"ApiTrain/internal/domain"
	"ApiTrain/internal/security"
	"ApiTrain/internal/store/postgres/userrepo"
	"errors"
)

// писать отдельный интерфейс или лучше методы в один запихнуть и передвать их я хз как ндао ээээ памагите (ЮЛЯ В ПОМОЩЬ)
type UserLogin interface {
	Login(loginData domain.LoginUserInternal) (string, error)
}

// Моментик прнимае указатель потому что с уровня стор вернули указатель или потому что будем менять поля структуры записывая туда jwt токен
// иными словами когда нам использовать указатель тут если мы передаем указатель с другого уровня что звукчит логично или когда что то меняем
// Прикинь походу указатель не нужен хотя мы прямо тут будем менять поля структуры внося туда токен класна (ЮЛЯ В ПОМОЩЬ)
//
// просто курва я устал задаваться бесконечными вопросами как мне писать код ебучая угадайка
// мне нужно jwt токен хранить как одно из полей внутренней структуры и относить его к сущности пользователя который логинится
// или нужно его просто передать как отдельную переменную и не ебать мозги в возращаемое значение типо нужно ли записать его в поле структры и потом вернуть
// как часть структуы или вернуть как отдельную переменную
// О боже чат гпт говорит миша все хуйня лучше отдельно вернуть токен без структуры )) (УЗНАТЬ У ЮЛИ)
//
// Рубрика очередные вопросы в сервисе регистрации мы сделали структру которая обрщатеся к интерфейсу который реализует метод регистрации, получения пользователя и логина
// собстаенно нужно ли мне определить новую структуру и как следствие новую функцию конструктор или использовать то что есть и глабализировать это
//если делать новые то прийдется и интерфейсы разделить на два с другой стороны при создании поста я же точно буду делать другую сруктру а значит и дургие
// интерфейсы ... сложно памагите(походу глобализировать но что правильно УЗНАТЬ У ЮЛИ)

// опять насрал с указателем при передаче структуры сукааа да как это работает мы же блять просто читаем то что делает база(уровень стор) или это завиит от принимаемых параметров методом аааааааааааааа убейте убейте меня
// очередной ахуенный вопрос тут когда мы реализуем метод имя параметро должно быть равно тому что мы указали в методе или нет или да потому что чисто и логично или да потому они логически связанны или нет потому что логически не связаны
var InvalidUsername error = errors.New("Invalid username or user does not exist")
var IncorrectPassword error = errors.New("Incorrect password") //вынести текст в константы в конце

func (s *UserService) Login(loginData domain.LoginUserInternal) (string, error) {
	var err error
	userData, err := s.userRepo.LoginByUsername(loginData.Username) // вместо userRepo передал store.UserRepository логическо верно сематически нет вообще так как мы же в поле передаем по ключу а не просто в воздух
	if err != nil {
		if err == userrepo.ErrUserNotFound {
			return "", InvalidUsername
		}
		return "", err
	}
	err = security.ComparePassword(userData.PasswordHash, loginData.Password)
	if err != nil {
		return "", IncorrectPassword
	}
	authToken, err := security.GenerateJWT(userData.ID)
	if err != nil {
		return "", err
	}
	return authToken, nil
}
